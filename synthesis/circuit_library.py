"""
FRANKENSTEIN 1.0 — Circuit Library
Persistent storage for quantum circuit definitions.

Circuits are stored as JSON in ~/.frankenstein/synthesis_data/circuits/
Export to OpenQASM 2.0 for portability to Qiskit, Quirk, IBM Quantum, etc.

Lazy-loaded: Only instantiated when circuit commands are used.
"""

import json
import logging
import time
from pathlib import Path
from typing import Dict, Any, Optional, List
from datetime import datetime

logger = logging.getLogger("frankenstein.circuits")


class CircuitDefinition:
    """
    A quantum circuit stored as a sequence of gate operations.

    This is Frankenstein's circuit IR (Intermediate Representation).
    Independent of Qiskit/QuTiP — can export to either.

    Format:
    {
        "name": "bell_pair",
        "description": "Creates a Bell state |Φ+⟩ = (|00⟩ + |11⟩)/√2",
        "n_qubits": 2,
        "created": "2026-02-20T14:30:00",
        "modified": "2026-02-20T14:35:00",
        "version": 1,
        "tags": ["entanglement", "bell", "2-qubit"],
        "gates": [
            {"gate": "h", "targets": [0], "params": {}},
            {"gate": "cx", "controls": [0], "targets": [1], "params": {}}
        ],
        "metadata": {
            "author": "adam",
            "hardware_tier": 1,
            "notes": "Standard Bell pair for entanglement verification"
        }
    }
    """

    def __init__(self, name: str, n_qubits: int, description: str = ""):
        self.name = name
        self.n_qubits = n_qubits
        self.description = description
        self.created = datetime.now().isoformat()
        self.modified = self.created
        self.version = 1
        self.tags: List[str] = []
        self.gates: List[Dict[str, Any]] = []
        self.metadata: Dict[str, Any] = {
            "author": "adam",
            "hardware_tier": 1,
            "notes": ""
        }

    def add_gate(self, gate: str, targets: List[int],
                 controls: Optional[List[int]] = None,
                 params: Optional[Dict[str, float]] = None):
        """Add a gate operation to the circuit."""
        entry = {
            "gate": gate.lower(),
            "targets": targets,
        }
        if controls:
            entry["controls"] = controls
        if params:
            entry["params"] = params
        else:
            entry["params"] = {}
        self.gates.append(entry)
        self.modified = datetime.now().isoformat()

    def to_dict(self) -> Dict[str, Any]:
        """Serialize to dictionary for JSON storage."""
        return {
            "name": self.name,
            "description": self.description,
            "n_qubits": self.n_qubits,
            "created": self.created,
            "modified": self.modified,
            "version": self.version,
            "tags": self.tags,
            "gates": self.gates,
            "metadata": self.metadata
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'CircuitDefinition':
        """Deserialize from dictionary."""
        circuit = cls(data["name"], data["n_qubits"], data.get("description", ""))
        circuit.created = data.get("created", datetime.now().isoformat())
        circuit.modified = data.get("modified", circuit.created)
        circuit.version = data.get("version", 1)
        circuit.tags = data.get("tags", [])
        circuit.gates = data.get("gates", [])
        circuit.metadata = data.get("metadata", {})
        return circuit

    def to_openqasm2(self) -> str:
        """
        Export circuit to OpenQASM 2.0 format.

        Reference: https://openqasm.com
        Spec: arXiv:1707.03429 (OpenQASM 2)

        This produces valid QASM that can be imported by:
        - Qiskit: qiskit.qasm2.loads(qasm_string)
        - IBM Quantum Experience
        - Quirk simulator
        - Any OpenQASM 2.0 compatible tool
        """
        lines = []
        lines.append("OPENQASM 2.0;")
        lines.append('include "qelib1.inc";')
        lines.append("")
        lines.append(f"// Circuit: {self.name}")
        if self.description:
            lines.append(f"// {self.description}")
        lines.append("// Generated by Frankenstein 1.0")
        lines.append(f"// Date: {datetime.now().isoformat()}")
        lines.append("")
        lines.append(f"qreg q[{self.n_qubits}];")
        lines.append(f"creg c[{self.n_qubits}];")
        lines.append("")

        # Gate mapping: Frankenstein gate names → OpenQASM 2.0
        GATE_MAP = {
            "h": "h",
            "x": "x", "y": "y", "z": "z",
            "s": "s", "t": "t",
            "sdg": "sdg", "tdg": "tdg",
            "rx": "rx", "ry": "ry", "rz": "rz",
            "cx": "cx", "cnot": "cx",
            "cz": "cz",
            "swap": "swap",
            "ccx": "ccx", "toffoli": "ccx",
            "phase": "p",
        }

        for g in self.gates:
            gate_name = GATE_MAP.get(g["gate"], g["gate"])
            targets = g["targets"]
            controls = g.get("controls", [])
            params = g.get("params", {})

            # Build parameter string
            param_str = ""
            if params:
                param_values = list(params.values())
                param_str = "(" + ", ".join(str(p) for p in param_values) + ")"

            # Build qubit argument string
            all_qubits = controls + targets
            qubit_str = ", ".join(f"q[{q}]" for q in all_qubits)

            lines.append(f"{gate_name}{param_str} {qubit_str};")

        lines.append("")
        return "\n".join(lines)

    def gate_count(self) -> Dict[str, int]:
        """Count gates by type."""
        counts: Dict[str, int] = {}
        for g in self.gates:
            name = g["gate"]
            counts[name] = counts.get(name, 0) + 1
        return counts

    def depth_estimate(self) -> int:
        """Estimate circuit depth (naive — sequential count)."""
        return len(self.gates)


class CircuitLibrary:
    """
    Persistent circuit library stored at ~/.frankenstein/synthesis_data/circuits/

    Lazy-loaded: Only instantiated when circuit commands are used.
    """

    def __init__(self, base_path: Optional[Path] = None):
        self.base_path = base_path or (Path.home() / ".frankenstein" / "synthesis_data" / "circuits")
        self.qasm_path = self.base_path / "qasm"

        # Create directories on first use
        self.base_path.mkdir(parents=True, exist_ok=True)
        self.qasm_path.mkdir(exist_ok=True)

    def save(self, circuit: CircuitDefinition) -> Path:
        """Save circuit to library."""
        filepath = self.base_path / f"{circuit.name}.json"

        # If overwriting, bump version
        if filepath.exists():
            existing = self.load(circuit.name)
            if existing:
                circuit.version = existing.version + 1
                circuit.created = existing.created  # Preserve original creation date

        filepath.write_text(json.dumps(circuit.to_dict(), indent=2))
        logger.info(f"Circuit saved: {circuit.name} (v{circuit.version})")
        return filepath

    def load(self, name: str) -> Optional[CircuitDefinition]:
        """Load circuit from library."""
        filepath = self.base_path / f"{name}.json"
        if not filepath.exists():
            return None

        try:
            data = json.loads(filepath.read_text())
            return CircuitDefinition.from_dict(data)
        except (json.JSONDecodeError, KeyError) as e:
            logger.error(f"Failed to load circuit {name}: {e}")
            return None

    def list_circuits(self) -> List[Dict[str, Any]]:
        """List all saved circuits with metadata summary."""
        circuits = []
        for f in sorted(self.base_path.glob("*.json")):
            try:
                data = json.loads(f.read_text())
                circuits.append({
                    "name": data.get("name", f.stem),
                    "n_qubits": data.get("n_qubits", "?"),
                    "gates": len(data.get("gates", [])),
                    "version": data.get("version", 1),
                    "modified": data.get("modified", "unknown"),
                    "description": data.get("description", "")[:60],
                    "size_bytes": f.stat().st_size,
                    "tags": data.get("tags", []),
                })
            except Exception:
                circuits.append({"name": f.stem, "error": "corrupt file"})
        return circuits

    def delete(self, name: str) -> bool:
        """Delete circuit from library."""
        filepath = self.base_path / f"{name}.json"
        qasm_file = self.qasm_path / f"{name}.qasm"

        deleted = False
        if filepath.exists():
            filepath.unlink()
            deleted = True
        if qasm_file.exists():
            qasm_file.unlink()

        if deleted:
            logger.info(f"Circuit deleted: {name}")
        return deleted

    def export_qasm(self, name: str) -> Optional[Path]:
        """Export circuit to OpenQASM 2.0 file."""
        circuit = self.load(name)
        if circuit is None:
            return None

        qasm_str = circuit.to_openqasm2()
        filepath = self.qasm_path / f"{name}.qasm"
        filepath.write_text(qasm_str)
        logger.info(f"Circuit exported to QASM: {filepath}")
        return filepath

    def get_storage_usage(self) -> Dict[str, Any]:
        """Get circuit library storage statistics."""
        total_size = 0
        circuit_count = 0
        qasm_count = 0

        for f in self.base_path.glob("*.json"):
            total_size += f.stat().st_size
            circuit_count += 1
        for f in self.qasm_path.glob("*.qasm"):
            total_size += f.stat().st_size
            qasm_count += 1

        return {
            "circuit_count": circuit_count,
            "qasm_exports": qasm_count,
            "total_bytes": total_size,
            "total_mb": round(total_size / (1024 * 1024), 3),
            "path": str(self.base_path),
        }


# ==================== SINGLETON (LAZY-LOADED) ====================

_circuit_library: Optional[CircuitLibrary] = None


def get_circuit_library() -> CircuitLibrary:
    """Get or create the global CircuitLibrary instance. Lazy-loaded."""
    global _circuit_library
    if _circuit_library is None:
        _circuit_library = CircuitLibrary()
    return _circuit_library
