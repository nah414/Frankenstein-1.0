<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FRANKENSTEIN - Multi-Qubit Bloch Sphere</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: radial-gradient(ellipse at center, #0a1628 0%, #000000 100%);
            overflow: hidden;
            font-family: 'Courier New', monospace;
            color: #00ff00;
        }

        #container { width: 100vw; height: 100vh; }

        /* Info Panels */
        .info-panel {
            position: absolute;
            background: rgba(0, 20, 0, 0.85);
            border: 2px solid rgba(0, 255, 0, 0.5);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.2);
            backdrop-filter: blur(10px);
            max-height: 85vh;
            overflow-y: auto;
        }

        .info-panel h3 {
            color: #00ff88;
            font-size: 1.1em;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            border-bottom: 1px solid rgba(0, 255, 0, 0.3);
            padding-bottom: 8px;
        }

        /* System Status Panel (Top Left) */
        #system-panel {
            top: 20px;
            left: 20px;
            min-width: 250px;
        }

        /* Probability Panel (Bottom Left) */
        #probability-panel {
            bottom: 20px;
            left: 20px;
            min-width: 320px;
            max-width: 400px;
            background: rgba(0, 20, 40, 0.9);
            border-color: rgba(0, 191, 255, 0.6);
        }

        #probability-panel h3 {
            color: #00bfff;
        }

        /* Entanglement Panel (Top Right) */
        #entanglement-panel {
            top: 20px;
            right: 20px;
            min-width: 280px;
            background: rgba(40, 0, 60, 0.85);
            border-color: rgba(138, 43, 226, 0.6);
        }

        #entanglement-panel h3 {
            color: #da70d6;
        }

        /* Qubit Grid (Bottom Right) */
        #qubit-grid {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: flex-end;
            max-width: 400px;
        }

        .qubit-card {
            background: rgba(0, 30, 40, 0.9);
            border: 2px solid rgba(0, 191, 255, 0.5);
            border-radius: 8px;
            padding: 10px;
            min-width: 90px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .qubit-card.entangled {
            border-color: #ff4081;
            box-shadow: 0 0 15px rgba(255, 64, 129, 0.5);
            animation: pulse-entangled 2s infinite;
        }

        .qubit-card .qubit-id {
            font-size: 0.9em;
            color: #00ffff;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .qubit-card .prob-label {
            font-size: 0.7em;
            color: #888;
            margin-top: 3px;
        }

        .qubit-card .prob-value {
            font-size: 0.85em;
            color: #00ff88;
            font-weight: bold;
        }

        .qubit-card .coords {
            font-size: 0.7em;
            color: #666;
            margin-top: 5px;
        }

        /* Stats Row */
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(0, 255, 0, 0.1);
        }

        .stat-row:last-child { border-bottom: none; }

        .stat-label { color: rgba(0, 255, 0, 0.7); font-size: 0.9em; }
        .stat-value {
            color: #00ff00;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
            font-size: 0.9em;
        }

        /* Probability Bars */
        .prob-bar-container {
            margin: 8px 0;
        }

        .prob-bar-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
            margin-bottom: 3px;
        }

        .prob-bar-label .basis-state {
            color: #00ffff;
            font-family: monospace;
        }

        .prob-bar-label .prob-percent {
            color: #00ff88;
        }

        .prob-bar-outer {
            width: 100%;
            height: 18px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .prob-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #0088ff 0%, #00ffff 100%);
            transition: width 0.5s ease;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .prob-bar-fill.experimental {
            background: linear-gradient(90deg, #ff6600 0%, #ffaa00 100%);
            box-shadow: 0 0 10px rgba(255, 170, 0, 0.5);
        }

        .prob-section-header {
            font-size: 0.9em;
            color: #00bfff;
            margin-top: 12px;
            margin-bottom: 6px;
            font-weight: bold;
            border-bottom: 1px solid rgba(0, 191, 255, 0.3);
            padding-bottom: 4px;
        }

        /* Entanglement Badge */
        .badge {
            display: inline-block;
            padding: 8px 20px;
            border-radius: 25px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .badge.entangled {
            background: rgba(255, 0, 100, 0.3);
            color: #ff4081;
            border: 2px solid #ff4081;
            animation: pulse-entangled 2s infinite;
        }

        .badge.separable {
            background: rgba(0, 255, 100, 0.3);
            color: #00ff88;
            border: 2px solid #00ff88;
        }

        @keyframes pulse-entangled {
            0%, 100% { box-shadow: 0 0 15px rgba(255, 64, 129, 0.5); }
            50% { box-shadow: 0 0 30px rgba(255, 64, 129, 0.8); }
        }

        /* Loading */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5em;
            color: #00ff00;
            text-shadow: 0 0 20px #00ff00;
        }

        /* Controls hint */
        #controls-hint {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8em;
            color: rgba(0, 255, 0, 0.5);
            text-align: center;
        }

        /* Scrollbar styling */
        .info-panel::-webkit-scrollbar { width: 8px; }
        .info-panel::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.3); }
        .info-panel::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 0, 0.3);
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div id="loading">‚öõÔ∏è Initializing Quantum Visualization...</div>
    <div id="container"></div>

    <!-- System Status Panel -->
    <div id="system-panel" class="info-panel">
        <h3>‚ö° System Status</h3>
        <div class="stat-row">
            <span class="stat-label">Qubits:</span>
            <span class="stat-value" id="num-qubits">{{NUM_QUBITS}}</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Gates Applied:</span>
            <span class="stat-value" id="gate-count">{{GATE_COUNT}}</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Tensor Backend:</span>
            <span class="stat-value" id="backend">{{BACKEND}}</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Measurement Shots:</span>
            <span class="stat-value" id="shots">{{SHOTS}}</span>
        </div>
    </div>

    <!-- Probability Panel -->
    <div id="probability-panel" class="info-panel">
        <h3>üìä Probability Distribution</h3>

        <div class="prob-section-header">üéØ Theoretical (Statevector)</div>
        <div id="theoretical-probs"></div>

        <div class="prob-section-header" id="experimental-header" style="display:none;">üî¨ Experimental (Measured)</div>
        <div id="experimental-probs"></div>

        <div class="prob-section-header">üî¢ Individual Qubit Marginals</div>
        <div id="marginal-probs"></div>
    </div>

    <!-- Entanglement Panel -->
    <div id="entanglement-panel" class="info-panel">
        <h3>‚öõÔ∏è Entanglement Analysis</h3>
        <div class="stat-row">
            <span class="stat-label">Schmidt Rank:</span>
            <span class="stat-value" id="schmidt-rank">{{SCHMIDT_RANK}}</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Entropy (bits):</span>
            <span class="stat-value" id="entropy">{{ENTROPY}}</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Max Entropy:</span>
            <span class="stat-value" id="max-entropy">{{MAX_ENTROPY}}</span>
        </div>
        <div style="text-align: center;">
            <span id="entanglement-badge" class="badge {{ENTANGLEMENT_CLASS}}">
                {{ENTANGLEMENT_STATUS}}
            </span>
        </div>
    </div>

    <!-- Qubit Cards -->
    <div id="qubit-grid"></div>

    <!-- Controls Hint -->
    <div id="controls-hint">
        üñ±Ô∏è Drag to rotate | Scroll to zoom | Double-click to reset
    </div>

    <script>
        // ==================== DATA FROM PYTHON ====================
        const NUM_QUBITS = {{NUM_QUBITS}};
        const QUBIT_COORDS = {{QUBIT_COORDS}};
        const IS_ENTANGLED = {{IS_ENTANGLED}};
        const SCHMIDT_RANK = {{SCHMIDT_RANK}};
        const ENTROPY = {{ENTROPY}};
        const THEORETICAL_PROBS = {{THEORETICAL_PROBS}};
        const EXPERIMENTAL_PROBS = {{EXPERIMENTAL_PROBS}};
        const MARGINAL_PROBS = {{MARGINAL_PROBS}};
        const SHOTS = {{SHOTS}};

        // ==================== THREE.JS SETUP ====================
        let scene, camera, renderer;
        let spheres = [];
        let stateArrows = [];
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let sphereGroup;

        const COLORS = {
            sphere: 0x003300,
            wireframe: 0x00ff00,
            axes: { x: 0xff0000, y: 0x00ff00, z: 0x0088ff },
            stateVector: 0x00ffff,
            entangled: 0xff4081,
            separable: 0x00ff88
        };

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000a14);

            // Camera
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 1000);

            // Position camera based on qubit count
            const gridSize = Math.ceil(Math.sqrt(NUM_QUBITS));
            camera.position.set(gridSize * 2, gridSize * 1.5, gridSize * 3);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);
            document.getElementById('loading').style.display = 'none';

            // Create sphere group
            sphereGroup = new THREE.Group();
            scene.add(sphereGroup);

            // Create Bloch spheres in grid
            createBlochSphereGrid();

            // Create qubit cards
            createQubitCards();

            // Create probability displays
            createProbabilityDisplays();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0x00ff00, 0.8);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);

            // Controls
            setupControls();

            // Start animation
            animate();
        }

        function createBlochSphereGrid() {
            const gridCols = Math.min(NUM_QUBITS, 4);
            const gridRows = Math.ceil(NUM_QUBITS / gridCols);
            const spacing = 3.0;

            for (let i = 0; i < NUM_QUBITS; i++) {
                const col = i % gridCols;
                const row = Math.floor(i / gridCols);

                const x = (col - (gridCols - 1) / 2) * spacing;
                const y = ((gridRows - 1) / 2 - row) * spacing;
                const z = 0;

                createSingleBlochSphere(i, x, y, z);
            }
        }

        function createSingleBlochSphere(qubitIndex, posX, posY, posZ) {
            const group = new THREE.Group();
            group.position.set(posX, posY, posZ);

            // Wireframe sphere
            const sphereGeom = new THREE.SphereGeometry(1, 24, 16);
            const wireframeMat = new THREE.MeshBasicMaterial({
                color: COLORS.wireframe,
                wireframe: true,
                transparent: true,
                opacity: 0.15
            });
            const sphere = new THREE.Mesh(sphereGeom, wireframeMat);
            group.add(sphere);
            spheres.push(sphere);

            // Axes
            const axisLength = 1.3;
            const axisColors = [COLORS.axes.x, COLORS.axes.y, COLORS.axes.z];
            const axisDirections = [
                new THREE.Vector3(1, 0, 0),
                new THREE.Vector3(0, 1, 0),
                new THREE.Vector3(0, 0, 1)
            ];

            axisDirections.forEach((dir, idx) => {
                const points = [
                    dir.clone().multiplyScalar(-axisLength),
                    dir.clone().multiplyScalar(axisLength)
                ];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: axisColors[idx],
                    transparent: true,
                    opacity: 0.5
                });
                const line = new THREE.Line(geometry, material);
                group.add(line);
            });

            // State vector arrow
            const coords = QUBIT_COORDS[qubitIndex] || [0, 0, 1];
            const [bx, by, bz] = coords;

            const arrowColor = IS_ENTANGLED ? COLORS.entangled : COLORS.stateVector;
            const arrowDir = new THREE.Vector3(bx, bz, by).normalize();
            const arrowLength = Math.sqrt(bx*bx + by*by + bz*bz);
            const arrowHelper = new THREE.ArrowHelper(
                arrowDir,
                new THREE.Vector3(0, 0, 0),
                arrowLength,
                arrowColor,
                0.2,
                0.1
            );
            group.add(arrowHelper);
            stateArrows.push(arrowHelper);

            // State point (glowing sphere at tip)
            const pointGeom = new THREE.SphereGeometry(0.08, 16, 16);
            const pointMat = new THREE.MeshBasicMaterial({
                color: arrowColor,
                transparent: true,
                opacity: 0.9
            });
            const statePoint = new THREE.Mesh(pointGeom, pointMat);
            statePoint.position.set(bx, bz, by);
            group.add(statePoint);

            sphereGroup.add(group);
        }

        function createQubitCards() {
            const grid = document.getElementById('qubit-grid');

            for (let i = 0; i < NUM_QUBITS; i++) {
                const coords = QUBIT_COORDS[i] || [0, 0, 1];
                const [x, y, z] = coords;

                // Get marginal probability for this qubit
                const margProb = MARGINAL_PROBS[i] || { p0: 0.5, p1: 0.5 };

                const card = document.createElement('div');
                card.className = 'qubit-card' + (IS_ENTANGLED ? ' entangled' : '');
                card.innerHTML = `
                    <div class="qubit-id">Q${i}</div>
                    <div class="prob-label">P(|0‚ü©) / P(|1‚ü©)</div>
                    <div class="prob-value">${(margProb.p0 * 100).toFixed(1)}% / ${(margProb.p1 * 100).toFixed(1)}%</div>
                    <div class="coords">
                        x: ${x.toFixed(2)}<br>
                        y: ${y.toFixed(2)}<br>
                        z: ${z.toFixed(2)}
                    </div>
                `;
                grid.appendChild(card);
            }
        }

        function createProbabilityDisplays() {
            // Theoretical probabilities
            const theoreticalDiv = document.getElementById('theoretical-probs');
            const sortedTheoretical = Object.entries(THEORETICAL_PROBS)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10); // Show top 10

            sortedTheoretical.forEach(([basis, prob]) => {
                const barDiv = document.createElement('div');
                barDiv.className = 'prob-bar-container';
                barDiv.innerHTML = `
                    <div class="prob-bar-label">
                        <span class="basis-state">|${basis}‚ü©</span>
                        <span class="prob-percent">${(prob * 100).toFixed(2)}%</span>
                    </div>
                    <div class="prob-bar-outer">
                        <div class="prob-bar-fill" style="width: ${prob * 100}%"></div>
                    </div>
                `;
                theoreticalDiv.appendChild(barDiv);
            });

            // Experimental probabilities (if measurements were taken)
            if (EXPERIMENTAL_PROBS && Object.keys(EXPERIMENTAL_PROBS).length > 0) {
                document.getElementById('experimental-header').style.display = 'block';
                const experimentalDiv = document.getElementById('experimental-probs');
                const sortedExperimental = Object.entries(EXPERIMENTAL_PROBS)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 10);

                sortedExperimental.forEach(([basis, prob]) => {
                    const barDiv = document.createElement('div');
                    barDiv.className = 'prob-bar-container';
                    barDiv.innerHTML = `
                        <div class="prob-bar-label">
                            <span class="basis-state">|${basis}‚ü©</span>
                            <span class="prob-percent">${(prob * 100).toFixed(2)}%</span>
                        </div>
                        <div class="prob-bar-outer">
                            <div class="prob-bar-fill experimental" style="width: ${prob * 100}%"></div>
                        </div>
                    `;
                    experimentalDiv.appendChild(barDiv);
                });
            }

            // Marginal probabilities
            const marginalDiv = document.getElementById('marginal-probs');
            MARGINAL_PROBS.forEach((margProb, i) => {
                const barDiv = document.createElement('div');
                barDiv.className = 'prob-bar-container';
                barDiv.innerHTML = `
                    <div class="prob-bar-label">
                        <span class="basis-state">Q${i}</span>
                        <span class="prob-percent">|0‚ü©: ${(margProb.p0 * 100).toFixed(1)}%  |1‚ü©: ${(margProb.p1 * 100).toFixed(1)}%</span>
                    </div>
                    <div class="prob-bar-outer">
                        <div class="prob-bar-fill" style="width: ${margProb.p0 * 100}%"></div>
                    </div>
                `;
                marginalDiv.appendChild(barDiv);
            });
        }

        function setupControls() {
            const canvas = renderer.domElement;

            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;

                sphereGroup.rotation.y += deltaX * 0.01;
                sphereGroup.rotation.x += deltaY * 0.01;

                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            canvas.addEventListener('mouseup', () => { isDragging = false; });
            canvas.addEventListener('mouseleave', () => { isDragging = false; });

            canvas.addEventListener('wheel', (e) => {
                camera.position.z += e.deltaY * 0.01;
                camera.position.z = Math.max(3, Math.min(20, camera.position.z));
            });

            canvas.addEventListener('dblclick', () => {
                sphereGroup.rotation.set(0, 0, 0);
                camera.position.set(
                    Math.ceil(Math.sqrt(NUM_QUBITS)) * 2,
                    Math.ceil(Math.sqrt(NUM_QUBITS)) * 1.5,
                    Math.ceil(Math.sqrt(NUM_QUBITS)) * 3
                );
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            // Gentle rotation when not dragging
            if (!isDragging) {
                sphereGroup.rotation.y += 0.002;
            }

            // Pulse entangled spheres
            if (IS_ENTANGLED) {
                const scale = 1 + 0.02 * Math.sin(Date.now() * 0.003);
                stateArrows.forEach(arrow => {
                    arrow.scale.setScalar(scale);
                });
            }

            renderer.render(scene, camera);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize
        init();
    </script>
</body>
</html>
