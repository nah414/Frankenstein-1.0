<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FRANKENSTEIN - Multi-Qubit Bloch Sphere</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #0d1117;
            overflow: hidden;
            font-family: 'Consolas', 'Courier New', monospace;
            color: #00ff88;
        }

        /* ── 3-column layout ──────────────────────────────────── */
        #layout {
            display: grid;
            grid-template-columns: 260px 1fr 290px;
            grid-template-rows: 100vh;
            width: 100vw;
            height: 100vh;
        }

        /* ── LEFT PANEL ───────────────────────────────────────── */
        #left-panel {
            background: #161b22;
            border-right: 2px solid #00ff88;
            padding: 12px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0;
        }

        #left-panel::-webkit-scrollbar { width: 5px; }
        #left-panel::-webkit-scrollbar-thumb { background: #30363d; border-radius: 3px; }

        .panel-title {
            color: #00ff88;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            padding: 6px 0 8px;
            text-shadow: 0 0 8px #00ff8866;
            border-bottom: 1px solid #30363d;
            margin-bottom: 8px;
        }

        .section-hdr {
            color: #58a6ff;
            font-size: 11px;
            font-weight: bold;
            margin: 8px 0 4px;
            padding-bottom: 3px;
            border-bottom: 1px solid #30363d;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            font-size: 10px;
        }
        .stat-label { color: #8b949e; }
        .stat-value { color: #00ff88; font-weight: bold; }

        /* Probability bars */
        .prob-bar-wrap { margin: 3px 0; }
        .prob-bar-hdr {
            display: flex;
            justify-content: space-between;
            font-size: 9px;
            margin-bottom: 1px;
        }
        .basis-state { color: #00ffff; font-family: monospace; }
        .prob-pct { color: #00ff88; }
        .prob-bar-outer {
            width: 100%;
            height: 13px;
            background: rgba(0,0,0,0.4);
            border: 1px solid rgba(0,255,255,0.2);
            border-radius: 3px;
            overflow: hidden;
        }
        .prob-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #0088ff, #00ffff);
            box-shadow: 0 0 6px rgba(0,255,255,0.4);
        }
        .prob-bar-fill.exp {
            background: linear-gradient(90deg, #ff6600, #ffaa00);
            box-shadow: 0 0 6px rgba(255,170,0,0.4);
        }

        /* Marginal rows */
        .marginal-row {
            display: flex; align-items: center;
            font-size: 9px; margin: 2px 0; gap: 3px;
        }
        .m-qid { color: #8b949e; width: 22px; flex-shrink: 0; }
        .m-bar { flex: 1; height: 9px; background: #21262d; border-radius: 2px; overflow: hidden; }
        .m-fill { height: 100%; background: linear-gradient(90deg, #00ccff, #0088aa); }
        .m-text { color: #00ff88; width: 110px; flex-shrink: 0; text-align: right; font-size: 8px; }

        /* ── CENTER: 3D scene ──────────────────────────────────── */
        #center-panel {
            position: relative;
            overflow: hidden;
        }
        #three-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #controls-hint {
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: rgba(0,255,136,0.5);
            pointer-events: none;
            white-space: nowrap;
        }
        #phase-badge {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #58a6ff;
            background: #161b22cc;
            padding: 3px 10px;
            border-radius: 4px;
            border: 1px solid #30363d;
        }

        /* ── RIGHT PANEL ──────────────────────────────────────── */
        #right-panel {
            background: #161b22;
            border-left: 2px solid #00ff88;
            padding: 12px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        #right-panel::-webkit-scrollbar { width: 5px; }
        #right-panel::-webkit-scrollbar-thumb { background: #30363d; border-radius: 3px; }

        /* Entanglement badge */
        .ent-badge {
            display: inline-block;
            padding: 5px 14px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 11px;
            letter-spacing: 1px;
            margin: 6px 0;
            text-align: center;
        }
        .ent-badge.entangled {
            background: rgba(255,0,100,0.2);
            color: #ff4081;
            border: 2px solid #ff4081;
            animation: pulse-ent 2s infinite;
        }
        .ent-badge.separable {
            background: rgba(0,255,100,0.15);
            color: #00ff88;
            border: 2px solid #00ff88;
        }
        @keyframes pulse-ent {
            0%,100% { box-shadow: 0 0 10px rgba(255,64,129,0.4); }
            50%      { box-shadow: 0 0 22px rgba(255,64,129,0.8); }
        }

        /* Q-cards grid */
        #q-cards-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 5px;
            margin-top: 6px;
        }
        .q-card {
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 5px;
            padding: 6px;
            text-align: center;
        }
        .q-card.entangled { border-color: #ff4081; }
        .q-id { color: #00ffff; font-weight: bold; font-size: 11px; margin-bottom: 2px; }
        .q-prob-label { color: #8b949e; font-size: 7px; }
        .q-prob { color: #00ff88; font-size: 9px; margin: 1px 0; }
        .q-xyz { color: #8b949e; font-size: 7px; line-height: 1.3; }

        /* Phase toggle button */
        #phase-btn {
            background: #21262d;
            color: #58a6ff;
            border: 1px solid #58a6ff;
            padding: 5px 12px;
            cursor: pointer;
            font-family: inherit;
            font-size: 10px;
            border-radius: 4px;
            margin-top: 8px;
            width: 100%;
            transition: all 0.2s;
        }
        #phase-btn:hover { background: #58a6ff; color: #0d1117; }
    </style>
</head>
<body>
<div id="layout">

    <!-- LEFT PANEL -->
    <div id="left-panel">
        <div class="panel-title">&#x1F9DF; FRANKENSTEIN<br>Bloch Sphere</div>

        <div class="section-hdr">&#x26A1; System Status</div>
        <div class="stat-row"><span class="stat-label">Qubits:</span><span class="stat-value">{{NUM_QUBITS}}</span></div>
        <div class="stat-row"><span class="stat-label">Gates Applied:</span><span class="stat-value">{{GATE_COUNT}}</span></div>
        <div class="stat-row"><span class="stat-label">Tensor Backend:</span><span class="stat-value">{{BACKEND}}</span></div>
        <div class="stat-row"><span class="stat-label">Shots:</span><span class="stat-value">{{SHOTS}}</span></div>

        <div class="section-hdr">&#x1F4CA; Probability Distribution</div>
        <div style="font-size:9px;color:#00bfff;margin:3px 0 2px;">&#x1F3AF; Theoretical (Statevector)</div>
        <div id="theoretical-probs"></div>
        <div id="exp-header" style="font-size:9px;color:#ff8800;margin:5px 0 2px;display:none;">&#x1F52C; Experimental (Measured)</div>
        <div id="experimental-probs"></div>

        <div class="section-hdr">&#x1F4CB; Individual Qubit Marginals</div>
        <div id="marginal-probs"></div>
    </div>

    <!-- CENTER: Three.js canvas -->
    <div id="center-panel">
        <canvas id="three-canvas"></canvas>
        <div id="controls-hint">&#x1F5B1;&#xFE0F; Drag to rotate | Scroll to zoom | Double-click to reset</div>
        <div id="phase-badge">&#x21BB; Global phase animating</div>
    </div>

    <!-- RIGHT PANEL -->
    <div id="right-panel">
        <div class="panel-title">&#x269B;&#xFE0F; Entanglement<br>Analysis</div>

        <div style="text-align:center;">
            <span id="ent-badge" class="ent-badge separable">&#x2713; SEPARABLE</span>
        </div>
        <div class="stat-row"><span class="stat-label">Schmidt Rank:</span><span class="stat-value">{{SCHMIDT_RANK}}</span></div>
        <div class="stat-row"><span class="stat-label">Entropy (bits):</span><span class="stat-value">{{ENTROPY}}</span></div>
        <div class="stat-row"><span class="stat-label">Max Entropy:</span><span class="stat-value">{{MAX_ENTROPY}}</span></div>

        <div class="section-hdr" style="margin-top:10px;">&#x1F4CB; Qubit States</div>
        <div id="q-cards-grid"></div>

        <button id="phase-btn" onclick="togglePhase()">&#x1F300; Pause Phase Animation</button>
    </div>
</div>

<script>
// ── DATA FROM PYTHON ──────────────────────────────────────────
var NUM_QUBITS       = {{NUM_QUBITS}};
var QUBIT_COORDS     = {{QUBIT_COORDS}};
var IS_ENTANGLED     = {{IS_ENTANGLED}};
var THEORETICAL_PROBS  = {{THEORETICAL_PROBS}};
var EXPERIMENTAL_PROBS = {{EXPERIMENTAL_PROBS}};
var MARGINAL_PROBS     = {{MARGINAL_PROBS}};

// ── THREE.JS GLOBALS ──────────────────────────────────────────
var scene, camera, renderer, sphereGroup;
var isDragging = false, prevMouse = {x:0, y:0};
var phaseActive = true;
var phaseOffset = 0.0;
var PHASE_SPEED = 0.022;

// Per-qubit live objects for phase animation
var qubitRefs = []; // {arrowHelper, dot, glowDot, center, coord}

// ── INIT ──────────────────────────────────────────────────────
function init() {
    var canvas = document.getElementById('three-canvas');
    var cp = document.getElementById('center-panel');

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000a14);

    var aspect = cp.clientWidth / cp.clientHeight;
    camera = new THREE.PerspectiveCamera(55, aspect, 0.1, 1000);

    renderer = new THREE.WebGLRenderer({canvas: canvas, antialias: true});
    renderer.setSize(cp.clientWidth, cp.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio);

    // Lights
    scene.add(new THREE.AmbientLight(0x404040, 0.6));
    var pl = new THREE.PointLight(0x00ff88, 0.8);
    pl.position.set(10, 10, 10);
    scene.add(pl);

    // Grid layout for spheres
    var cols = Math.ceil(Math.sqrt(NUM_QUBITS));
    var rows = Math.ceil(NUM_QUBITS / cols);
    var spacing = 3.2;
    var R = Math.max(0.45, 1.15 - 0.055 * (NUM_QUBITS - 1));

    // Camera position
    var camDist = Math.max(cols, rows) * spacing * 0.9;
    camera.position.set(camDist * 0.55, camDist * 0.45, camDist);
    camera.lookAt((cols - 1) * spacing / 2, 0, (rows - 1) * spacing / 2);

    sphereGroup = new THREE.Group();
    scene.add(sphereGroup);

    // Build spheres
    qubitRefs = [];
    for (var qi = 0; qi < NUM_QUBITS; qi++) {
        var col = qi % cols;
        var row = Math.floor(qi / cols);
        var cx = col * spacing;
        var cz = row * spacing;
        var center = new THREE.Vector3(cx, 0, cz);
        buildBlochSphere(qi, center, R);
    }

    // Entanglement connecting lines
    if (IS_ENTANGLED) {
        for (var i = 1; i < NUM_QUBITS; i++) {
            var a = qubitRefs[i-1].center;
            var b = qubitRefs[i].center;
            var pts = [a.clone(), b.clone()];
            var geo = new THREE.BufferGeometry().setFromPoints(pts);
            var mat = new THREE.LineBasicMaterial({color: 0xff4081, transparent: true, opacity: 0.35});
            sphereGroup.add(new THREE.Line(geo, mat));
        }
    }

    // Entanglement badge
    if (IS_ENTANGLED) {
        var badge = document.getElementById('ent-badge');
        badge.className = 'ent-badge entangled';
        badge.textContent = 'ENTANGLED';
    }

    // UI panels
    buildQCards(R);
    buildProbBars();
    buildMarginals();

    setupControls(canvas, cp);
    animate();
}

// ── BUILD ONE 3D BLOCH SPHERE ─────────────────────────────────
function buildBlochSphere(qi, center, R) {
    var coord = QUBIT_COORDS[qi] || [0, 0, 1];
    var bx = coord[0], by = coord[1], bz = coord[2];

    // Wireframe sphere
    var wf = new THREE.Mesh(
        new THREE.SphereGeometry(R, 24, 18),
        new THREE.MeshBasicMaterial({color: 0x00ff00, wireframe: true, transparent: true, opacity: 0.14})
    );
    wf.position.copy(center);
    sphereGroup.add(wf);

    // Inner solid
    var inner = new THREE.Mesh(
        new THREE.SphereGeometry(R * 0.97, 20, 16),
        new THREE.MeshPhongMaterial({color: 0x0a1628, transparent: true, opacity: 0.25, side: THREE.DoubleSide})
    );
    inner.position.copy(center);
    sphereGroup.add(inner);

    // Equator ring
    var eq = new THREE.Mesh(
        new THREE.RingGeometry(R * 0.99, R * 1.015, 64),
        new THREE.MeshBasicMaterial({color: 0x4ecdc4, side: THREE.DoubleSide, transparent: true, opacity: 0.4})
    );
    eq.position.copy(center);
    eq.rotation.x = Math.PI / 2;
    sphereGroup.add(eq);

    // Meridian ring
    var mer = new THREE.Mesh(
        new THREE.RingGeometry(R * 0.99, R * 1.015, 64),
        new THREE.MeshBasicMaterial({color: 0x58a6ff, side: THREE.DoubleSide, transparent: true, opacity: 0.2})
    );
    mer.position.copy(center);
    sphereGroup.add(mer);

    // Axis lines
    var zMat = new THREE.LineBasicMaterial({color: 0xffe66d, transparent: true, opacity: 0.2});
    sphereGroup.add(new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(center.x, center.y - R*1.2, center.z),
            new THREE.Vector3(center.x, center.y + R*1.2, center.z)
        ]), zMat
    ));
    var xMat = new THREE.LineBasicMaterial({color: 0xff6b6b, transparent: true, opacity: 0.15});
    sphereGroup.add(new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(center.x - R*1.2, center.y, center.z),
            new THREE.Vector3(center.x + R*1.2, center.y, center.z)
        ]), xMat
    ));

    // Phase orbit ring at height bz (shows rotation path)
    var r_xy = Math.sqrt(bx*bx + by*by);
    if (r_xy > 0.02) {
        var orbitRing = new THREE.Mesh(
            new THREE.RingGeometry(r_xy*R*0.97, r_xy*R*1.03, 64),
            new THREE.MeshBasicMaterial({color: 0x58a6ff, side: THREE.DoubleSide, transparent: true, opacity: 0.3})
        );
        orbitRing.position.set(center.x, center.y + bz*R, center.z);
        orbitRing.rotation.x = Math.PI / 2;
        sphereGroup.add(orbitRing);
    }

    // |0> / |1> labels
    var lbl0 = makeSprite('|0>', 0xffe66d);
    lbl0.position.set(center.x, center.y + R + 0.18, center.z);
    lbl0.scale.set(0.28, 0.14, 1);
    sphereGroup.add(lbl0);
    var lbl1 = makeSprite('|1>', 0xffe66d);
    lbl1.position.set(center.x, center.y - R - 0.18, center.z);
    lbl1.scale.set(0.28, 0.14, 1);
    sphereGroup.add(lbl1);

    // Qubit label
    var qlbl = makeSprite('Q' + qi, IS_ENTANGLED ? 0xff4081 : 0x8b949e);
    qlbl.position.set(center.x, center.y - R - 0.38, center.z);
    qlbl.scale.set(0.32, 0.16, 1);
    sphereGroup.add(qlbl);

    // State vector arrow
    var arrowColor = IS_ENTANGLED ? 0xff4081 : 0x00ffff;
    var dir = new THREE.Vector3(bx*R, bz*R, by*R);
    var len = dir.length();
    dir.normalize();
    var arrow = new THREE.ArrowHelper(dir, center, len, arrowColor, 0.14*R, 0.07*R);
    sphereGroup.add(arrow);

    // State dot at tip
    var dot = new THREE.Mesh(
        new THREE.SphereGeometry(0.07*R, 14, 14),
        new THREE.MeshBasicMaterial({color: arrowColor, transparent: true, opacity: 0.95})
    );
    dot.position.set(center.x + bx*R, center.y + bz*R, center.z + by*R);
    sphereGroup.add(dot);

    // Glow
    var glow = new THREE.Mesh(
        new THREE.SphereGeometry(0.12*R, 12, 12),
        new THREE.MeshBasicMaterial({color: arrowColor, transparent: true, opacity: 0.25})
    );
    glow.position.copy(dot.position);
    sphereGroup.add(glow);

    qubitRefs.push({arrow: arrow, dot: dot, glowDot: glow, center: center.clone(), coord: coord, R: R});
}

function makeSprite(text, color) {
    var c = document.createElement('canvas');
    c.width = 128; c.height = 64;
    var ctx = c.getContext('2d');
    ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
    ctx.font = 'bold 26px Consolas';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, 64, 32);
    return new THREE.Sprite(new THREE.SpriteMaterial({map: new THREE.CanvasTexture(c)}));
}

// ── BUILD RIGHT PANEL Q-CARDS ─────────────────────────────────
function buildQCards() {
    var grid = document.getElementById('q-cards-grid');
    var n = NUM_QUBITS;
    var cols = n <= 8 ? 2 : 3;
    grid.style.gridTemplateColumns = 'repeat(' + cols + ', 1fr)';
    var fId = Math.max(8, Math.round(11 - 0.22 * n)) + 'px';
    var fSm = Math.max(6, Math.round(8  - 0.13 * n)) + 'px';

    for (var i = 0; i < n; i++) {
        var coord = QUBIT_COORDS[i] || [0, 0, 1];
        var bz = coord[2];
        var p0 = ((1 + bz) / 2 * 100).toFixed(1);
        var p1 = ((1 - bz) / 2 * 100).toFixed(1);
        var card = document.createElement('div');
        card.className = 'q-card' + (IS_ENTANGLED ? ' entangled' : '');
        card.innerHTML =
            '<div class="q-id" style="font-size:' + fId + '">Q' + i + '</div>' +
            '<div class="q-prob-label" style="font-size:' + fSm + '">P(|0>) / P(|1>)</div>' +
            '<div class="q-prob" style="font-size:' + fId + '">' + p0 + '% / ' + p1 + '%</div>' +
            '<div class="q-xyz" style="font-size:' + fSm + '">' +
            'x: ' + coord[0].toFixed(2) + '<br>y: ' + coord[1].toFixed(2) + '<br>z: ' + coord[2].toFixed(2) + '</div>';
        grid.appendChild(card);
    }
}

// ── BUILD LEFT PANEL PROBABILITY BARS ─────────────────────────
function buildProbBars() {
    // Theoretical
    var theoDiv = document.getElementById('theoretical-probs');
    var tEntries = Object.entries(THEORETICAL_PROBS).sort(function(a,b){return b[1]-a[1];}).slice(0, 16);
    tEntries.forEach(function(e) {
        var wrap = document.createElement('div');
        wrap.className = 'prob-bar-wrap';
        wrap.innerHTML =
            '<div class="prob-bar-hdr"><span class="basis-state">|' + e[0] + '></span><span class="prob-pct">' + (e[1]*100).toFixed(2) + '%</span></div>' +
            '<div class="prob-bar-outer"><div class="prob-bar-fill" style="width:' + (e[1]*100) + '%"></div></div>';
        theoDiv.appendChild(wrap);
    });

    // Experimental
    if (EXPERIMENTAL_PROBS && Object.keys(EXPERIMENTAL_PROBS).length > 0) {
        document.getElementById('exp-header').style.display = 'block';
        var expDiv = document.getElementById('experimental-probs');
        var eEntries = Object.entries(EXPERIMENTAL_PROBS).sort(function(a,b){return b[1]-a[1];}).slice(0, 16);
        eEntries.forEach(function(e) {
            var wrap = document.createElement('div');
            wrap.className = 'prob-bar-wrap';
            wrap.innerHTML =
                '<div class="prob-bar-hdr"><span class="basis-state">|' + e[0] + '></span><span class="prob-pct">' + (e[1]*100).toFixed(2) + '%</span></div>' +
                '<div class="prob-bar-outer"><div class="prob-bar-fill exp" style="width:' + (e[1]*100) + '%"></div></div>';
            expDiv.appendChild(wrap);
        });
    }
}

// ── BUILD MARGINALS ───────────────────────────────────────────
function buildMarginals() {
    var div = document.getElementById('marginal-probs');
    MARGINAL_PROBS.forEach(function(m, i) {
        var row = document.createElement('div');
        row.className = 'marginal-row';
        row.innerHTML =
            '<span class="m-qid">Q' + i + '</span>' +
            '<span class="m-bar"><span class="m-fill" style="width:' + (m.p0*100) + '%"></span></span>' +
            '<span class="m-text">|0>: ' + (m.p0*100).toFixed(1) + '%  |1>: ' + (m.p1*100).toFixed(1) + '%</span>';
        div.appendChild(row);
    });
}

// ── MOUSE CONTROLS ────────────────────────────────────────────
function setupControls(canvas, cp) {
    canvas.addEventListener('mousedown', function(e) {
        isDragging = true;
        prevMouse = {x: e.clientX, y: e.clientY};
    });
    canvas.addEventListener('mousemove', function(e) {
        if (!isDragging) return;
        sphereGroup.rotation.y += (e.clientX - prevMouse.x) * 0.008;
        sphereGroup.rotation.x += (e.clientY - prevMouse.y) * 0.008;
        prevMouse = {x: e.clientX, y: e.clientY};
    });
    canvas.addEventListener('mouseup', function() { isDragging = false; });
    canvas.addEventListener('mouseleave', function() { isDragging = false; });
    canvas.addEventListener('wheel', function(e) {
        camera.position.z += e.deltaY * 0.01;
        camera.position.z = Math.max(3, Math.min(40, camera.position.z));
    });
    canvas.addEventListener('dblclick', function() {
        sphereGroup.rotation.set(0, 0, 0);
        var cols = Math.ceil(Math.sqrt(NUM_QUBITS));
        var rows = Math.ceil(NUM_QUBITS / cols);
        var spacing = 3.2;
        var d = Math.max(cols, rows) * spacing * 0.9;
        camera.position.set(d*0.55, d*0.45, d);
        camera.lookAt((cols-1)*spacing/2, 0, (rows-1)*spacing/2);
    });
    window.addEventListener('resize', function() {
        camera.aspect = cp.clientWidth / cp.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(cp.clientWidth, cp.clientHeight);
    });
}

// ── ANIMATION LOOP with PHASE ROTATION ───────────────────────
function animate() {
    requestAnimationFrame(animate);

    if (phaseActive) {
        phaseOffset += PHASE_SPEED;
        if (phaseOffset > Math.PI * 2) phaseOffset -= Math.PI * 2;

        for (var i = 0; i < qubitRefs.length; i++) {
            var qr = qubitRefs[i];
            var bx = qr.coord[0], by = qr.coord[1], bz = qr.coord[2];
            var r_xy = Math.sqrt(bx*bx + by*by);

            if (r_xy > 0.02) {
                // Rotate state point around Z-axis
                var phi0 = Math.atan2(by, bx);
                var phiA = phi0 + phaseOffset;
                var newBx = r_xy * Math.cos(phiA);
                var newBy = r_xy * Math.sin(phiA);
                var R = qr.R;
                var cx = qr.center.x, cy = qr.center.y, cz = qr.center.z;

                // Move dot + glow
                qr.dot.position.set(cx + newBx*R, cy + bz*R, cz + newBy*R);
                qr.glowDot.position.copy(qr.dot.position);

                // Rebuild arrow pointing to new position
                sphereGroup.remove(qr.arrow);
                var dir = new THREE.Vector3(newBx*R, bz*R, newBy*R);
                var len = dir.length();
                dir.normalize();
                var arrowColor = IS_ENTANGLED ? 0xff4081 : 0x00ffff;
                qr.arrow = new THREE.ArrowHelper(dir, qr.center, len, arrowColor, 0.14*R, 0.07*R);
                sphereGroup.add(qr.arrow);
            }

            // Pulse glow
            var pulse = 1 + 0.1 * Math.sin(Date.now() * 0.003 + i * 0.5);
            qr.glowDot.scale.setScalar(pulse);
        }
    }

    renderer.render(scene, camera);
}

// ── PHASE TOGGLE ──────────────────────────────────────────────
function togglePhase() {
    phaseActive = !phaseActive;
    var btn = document.getElementById('phase-btn');
    var badge = document.getElementById('phase-badge');
    btn.textContent = phaseActive ? '\u21BB Pause Phase Animation' : '\u25B6 Resume Phase Animation';
    badge.style.opacity = phaseActive ? '1' : '0.3';
}

// ── START ─────────────────────────────────────────────────────
init();
</script>
</body>
</html>
