<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚ö° FRANKENSTEIN - Bloch Sphere Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #0d1117;
            color: #00ff88;
            font-family: 'Consolas', 'Monaco', monospace;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            display: flex;
        }
        
        #canvas-container {
            flex: 1;
            position: relative;
        }
        
        #info-panel {
            width: 320px;
            background: #161b22;
            border-left: 2px solid #00ff88;
            padding: 20px;
            overflow-y: auto;
        }
        
        h1 {
            color: #00ff88;
            font-size: 18px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #00ff8866;
        }
        
        h2 {
            color: #58a6ff;
            font-size: 14px;
            margin: 15px 0 10px 0;
            border-bottom: 1px solid #30363d;
            padding-bottom: 5px;
        }
        
        .data-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 12px;
        }
        
        .label {
            color: #8b949e;
        }
        
        .value {
            color: #00ff88;
            font-weight: bold;
        }
        
        .state-display {
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            font-size: 14px;
            text-align: center;
        }
        
        .prob-bar {
            background: #21262d;
            border-radius: 3px;
            height: 20px;
            margin: 5px 0;
            position: relative;
            overflow: hidden;
        }
        
        .prob-fill {
            background: linear-gradient(90deg, #00ff88, #00aa55);
            height: 100%;
            transition: width 0.3s ease;
        }
        
        .prob-label {
            position: absolute;
            left: 8px;
            top: 2px;
            font-size: 11px;
            color: #fff;
            text-shadow: 1px 1px 2px #000;
        }
        
        .controls {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #30363d;
        }
        
        button {
            background: #21262d;
            color: #00ff88;
            border: 1px solid #00ff88;
            padding: 8px 16px;
            margin: 5px;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        
        button:hover {
            background: #00ff88;
            color: #0d1117;
        }
        
        #coordinates {
            font-size: 13px;
            line-height: 1.8;
        }
        
        .coord-value {
            display: inline-block;
            width: 100px;
            text-align: right;
        }
        
        .axis-x { color: #ff6b6b; }
        .axis-y { color: #4ecdc4; }
        .axis-z { color: #ffe66d; }
        
        #status {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: #161b22ee;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 11px;
            border: 1px solid #30363d;
        }
        
        .frank-banner {
            text-align: center;
            padding: 10px;
            margin-bottom: 15px;
            background: linear-gradient(180deg, #1a1a2e 0%, #0d1117 100%);
            border-radius: 6px;
            border: 1px solid #00ff8844;
        }
        
        .frank-banner .emoji {
            font-size: 24px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container">
            <canvas id="bloch-canvas"></canvas>
            <div id="status">‚ö° FRANKENSTEIN 1.0 | Drag to rotate | Scroll to zoom</div>
        </div>
        
        <div id="info-panel">
            <div class="frank-banner">
                <span class="emoji">üßü</span>
                <h1>FRANKENSTEIN<br>Bloch Sphere</h1>
            </div>
            
            <h2>üìç Bloch Coordinates</h2>
            <div id="coordinates">
                <div class="data-row">
                    <span class="label axis-x">X:</span>
                    <span class="value coord-value" id="coord-x">0.000000</span>
                </div>
                <div class="data-row">
                    <span class="label axis-y">Y:</span>
                    <span class="value coord-value" id="coord-y">0.000000</span>
                </div>
                <div class="data-row">
                    <span class="label axis-z">Z:</span>
                    <span class="value coord-value" id="coord-z">1.000000</span>
                </div>
            </div>
            
            <h2>üé≤ Quantum State</h2>
            <div class="state-display" id="state-ket">|œà‚ü© = |0‚ü©</div>
            
            <h2>üìä Measurement Probabilities</h2>
            <div id="probabilities">
                <div class="prob-bar">
                    <div class="prob-fill" id="prob-0-fill" style="width: 100%"></div>
                    <span class="prob-label">|0‚ü©: 100.0%</span>
                </div>
                <div class="prob-bar">
                    <div class="prob-fill" id="prob-1-fill" style="width: 0%"></div>
                    <span class="prob-label">|1‚ü©: 0.0%</span>
                </div>
            </div>
            
            <h2>üéõÔ∏è Spherical Coordinates</h2>
            <div id="spherical">
                <div class="data-row">
                    <span class="label">Œ∏ (polar):</span>
                    <span class="value" id="theta">0.000 rad</span>
                </div>
                <div class="data-row">
                    <span class="label">œÜ (azimuth):</span>
                    <span class="value" id="phi">0.000 rad</span>
                </div>
                <div class="data-row">
                    <span class="label">r (purity):</span>
                    <span class="value" id="purity">1.000</span>
                </div>
            </div>
            
            <div class="controls">
                <button onclick="resetView()">üîÑ Reset View</button>
                <button onclick="toggleAnimation()">‚èØÔ∏è Animate</button>
                <button onclick="toggleAxes()">üìê Axes</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ==================== DATA FROM FRANKENSTEIN ====================
        // These placeholders are replaced by the Python engine
        const BLOCH_X = parseFloat('{{BLOCH_X}}') || 0;
        const BLOCH_Y = parseFloat('{{BLOCH_Y}}') || 0;
        const BLOCH_Z = parseFloat('{{BLOCH_Z}}') || 1;
        const PROBABILITIES = JSON.parse('{{PROBABILITIES}}' || '{}');
        const STATEVECTOR = JSON.parse('{{STATEVECTOR}}' || '{"real":[1,0],"imag":[0,0]}');
        
        // ==================== THREE.JS SETUP ====================
        let scene, camera, renderer, controls;
        let sphere, stateVector, statePoint;
        let axesGroup, animating = false, showAxes = true;
        
        const canvas = document.getElementById('bloch-canvas');
        const container = document.getElementById('canvas-container');
        
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0d1117);
            
            // Camera
            const aspect = container.clientWidth / container.clientHeight;
            camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 1000);
            camera.position.set(2.5, 2, 2.5);
            camera.lookAt(0, 0, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);
            
            const backLight = new THREE.DirectionalLight(0x00ff88, 0.3);
            backLight.position.set(-5, -5, -5);
            scene.add(backLight);
            
            // Create Bloch sphere
            createBlochSphere();
            
            // Create state visualization
            createStateVisualization(BLOCH_X, BLOCH_Y, BLOCH_Z);
            
            // Create axes
            createAxes();
            
            // Mouse controls (simple orbit)
            setupControls();
            
            // Update info panel
            updateInfoPanel(BLOCH_X, BLOCH_Y, BLOCH_Z);
            
            // Animation loop
            animate();
        }
        
        function createBlochSphere() {
            // Main sphere (wireframe)
            const sphereGeometry = new THREE.SphereGeometry(1, 32, 32);
            const sphereMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff88,
                wireframe: true,
                transparent: true,
                opacity: 0.15
            });
            sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            scene.add(sphere);
            
            // Solid inner sphere (slightly transparent)
            const innerSphereGeometry = new THREE.SphereGeometry(0.98, 32, 32);
            const innerSphereMaterial = new THREE.MeshPhongMaterial({
                color: 0x1a1a2e,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const innerSphere = new THREE.Mesh(innerSphereGeometry, innerSphereMaterial);
            scene.add(innerSphere);
            
            // Equator circle
            const equatorGeometry = new THREE.RingGeometry(0.99, 1.01, 64);
            const equatorMaterial = new THREE.MeshBasicMaterial({
                color: 0x4ecdc4,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.5
            });
            const equator = new THREE.Mesh(equatorGeometry, equatorMaterial);
            equator.rotation.x = Math.PI / 2;
            scene.add(equator);
            
            // Prime meridian (XZ plane)
            const meridianGeometry = new THREE.RingGeometry(0.99, 1.01, 64);
            const meridianMaterial = new THREE.MeshBasicMaterial({
                color: 0x58a6ff,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.3
            });
            const meridian = new THREE.Mesh(meridianGeometry, meridianMaterial);
            scene.add(meridian);
        }
        
        function createStateVisualization(x, y, z) {
            // State vector (arrow from origin to point)
            const direction = new THREE.Vector3(x, z, y); // Note: Three.js Y is up
            const length = direction.length();
            direction.normalize();
            
            // Arrow helper
            stateVector = new THREE.ArrowHelper(
                direction,
                new THREE.Vector3(0, 0, 0),
                length,
                0x00ff88,
                0.15,
                0.08
            );
            scene.add(stateVector);
            
            // State point (glowing sphere at tip)
            const pointGeometry = new THREE.SphereGeometry(0.08, 16, 16);
            const pointMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff88,
                transparent: true,
                opacity: 0.9
            });
            statePoint = new THREE.Mesh(pointGeometry, pointMaterial);
            statePoint.position.set(x, z, y); // Three.js Y-up convention
            scene.add(statePoint);
            
            // Glow effect
            const glowGeometry = new THREE.SphereGeometry(0.12, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff88,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.copy(statePoint.position);
            scene.add(glow);
        }
        
        function createAxes() {
            axesGroup = new THREE.Group();
            
            const axisLength = 1.3;
            const colors = {
                x: 0xff6b6b,  // Red
                y: 0x4ecdc4,  // Cyan
                z: 0xffe66d   // Yellow
            };
            
            // X axis
            const xAxis = new THREE.ArrowHelper(
                new THREE.Vector3(1, 0, 0),
                new THREE.Vector3(-axisLength, 0, 0),
                axisLength * 2,
                colors.x,
                0.1,
                0.05
            );
            axesGroup.add(xAxis);
            
            // Y axis (mapped to Z in Three.js)
            const yAxis = new THREE.ArrowHelper(
                new THREE.Vector3(0, 0, 1),
                new THREE.Vector3(0, 0, -axisLength),
                axisLength * 2,
                colors.y,
                0.1,
                0.05
            );
            axesGroup.add(yAxis);
            
            // Z axis (mapped to Y in Three.js - vertical)
            const zAxis = new THREE.ArrowHelper(
                new THREE.Vector3(0, 1, 0),
                new THREE.Vector3(0, -axisLength, 0),
                axisLength * 2,
                colors.z,
                0.1,
                0.05
            );
            axesGroup.add(zAxis);
            
            // Labels (using sprites)
            addAxisLabel('X', axisLength + 0.2, 0, 0, colors.x);
            addAxisLabel('Y', 0, 0, axisLength + 0.2, colors.y);
            addAxisLabel('|0‚ü©', 0, axisLength + 0.2, 0, colors.z);
            addAxisLabel('|1‚ü©', 0, -axisLength - 0.2, 0, colors.z);
            
            scene.add(axesGroup);
        }
        
        function addAxisLabel(text, x, y, z, color) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 64;
            canvas.height = 64;
            
            context.fillStyle = '#' + color.toString(16).padStart(6, '0');
            context.font = 'bold 32px Consolas';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, 32, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(x, y, z);
            sprite.scale.set(0.3, 0.3, 1);
            axesGroup.add(sprite);
        }
        
        // ==================== CONTROLS ====================
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let sphereRotation = { x: 0, y: 0 };
        
        function setupControls() {
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const deltaMove = {
                    x: e.clientX - previousMousePosition.x,
                    y: e.clientY - previousMousePosition.y
                };
                
                sphereRotation.y += deltaMove.x * 0.01;
                sphereRotation.x += deltaMove.y * 0.01;
                
                // Clamp vertical rotation
                sphereRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, sphereRotation.x));
                
                updateCameraPosition();
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            canvas.addEventListener('mouseup', () => { isDragging = false; });
            canvas.addEventListener('mouseleave', () => { isDragging = false; });
            
            // Zoom with scroll
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoom = e.deltaY * 0.001;
                camera.position.multiplyScalar(1 + zoom);
                
                // Clamp zoom
                const dist = camera.position.length();
                if (dist < 2) camera.position.setLength(2);
                if (dist > 10) camera.position.setLength(10);
            });
            
            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
        }
        
        function updateCameraPosition() {
            const radius = camera.position.length();
            camera.position.x = radius * Math.cos(sphereRotation.x) * Math.sin(sphereRotation.y);
            camera.position.y = radius * Math.sin(sphereRotation.x);
            camera.position.z = radius * Math.cos(sphereRotation.x) * Math.cos(sphereRotation.y);
            camera.lookAt(0, 0, 0);
        }
        
        // ==================== INFO PANEL ====================
        function updateInfoPanel(x, y, z) {
            // Bloch coordinates
            document.getElementById('coord-x').textContent = x.toFixed(6);
            document.getElementById('coord-y').textContent = y.toFixed(6);
            document.getElementById('coord-z').textContent = z.toFixed(6);
            
            // Spherical coordinates
            const r = Math.sqrt(x*x + y*y + z*z);
            const theta = Math.acos(z / (r || 1));
            const phi = Math.atan2(y, x);
            
            document.getElementById('theta').textContent = theta.toFixed(3) + ' rad';
            document.getElementById('phi').textContent = phi.toFixed(3) + ' rad';
            document.getElementById('purity').textContent = r.toFixed(3);
            
            // State ket notation
            updateStateKet();
            
            // Probabilities
            updateProbabilities();
        }
        
        function updateStateKet() {
            const sv = STATEVECTOR;
            if (!sv || !sv.real) return;
            
            const alpha = { re: sv.real[0], im: sv.imag[0] };
            const beta = { re: sv.real[1], im: sv.imag[1] };
            
            const formatComplex = (c) => {
                const re = c.re.toFixed(3);
                const im = c.im.toFixed(3);
                if (Math.abs(c.im) < 0.001) return re;
                if (Math.abs(c.re) < 0.001) return im + 'i';
                return `(${re}${c.im >= 0 ? '+' : ''}${im}i)`;
            };
            
            let ket = '|œà‚ü© = ';
            const alphaMag = Math.sqrt(alpha.re*alpha.re + alpha.im*alpha.im);
            const betaMag = Math.sqrt(beta.re*beta.re + beta.im*beta.im);
            
            if (alphaMag > 0.001) {
                ket += formatComplex(alpha) + '|0‚ü©';
            }
            if (betaMag > 0.001) {
                if (alphaMag > 0.001) ket += ' + ';
                ket += formatComplex(beta) + '|1‚ü©';
            }
            
            document.getElementById('state-ket').textContent = ket;
        }
        
        function updateProbabilities() {
            const probs = PROBABILITIES;
            const prob0 = (probs['0'] || probs['00'] || 0) * 100;
            const prob1 = (probs['1'] || probs['01'] || 0) * 100;
            
            // If we have statevector, calculate directly
            if (STATEVECTOR && STATEVECTOR.real) {
                const p0 = STATEVECTOR.real[0]**2 + STATEVECTOR.imag[0]**2;
                const p1 = STATEVECTOR.real[1]**2 + STATEVECTOR.imag[1]**2;
                
                document.getElementById('prob-0-fill').style.width = (p0 * 100) + '%';
                document.getElementById('prob-0-fill').parentElement.querySelector('.prob-label').textContent = 
                    `|0‚ü©: ${(p0 * 100).toFixed(1)}%`;
                
                document.getElementById('prob-1-fill').style.width = (p1 * 100) + '%';
                document.getElementById('prob-1-fill').parentElement.querySelector('.prob-label').textContent = 
                    `|1‚ü©: ${(p1 * 100).toFixed(1)}%`;
            }
        }
        
        // ==================== ANIMATION ====================
        function animate() {
            requestAnimationFrame(animate);
            
            if (animating) {
                // Gentle rotation when animating
                scene.rotation.y += 0.005;
            }
            
            // Pulse effect on state point
            if (statePoint) {
                const scale = 1 + 0.1 * Math.sin(Date.now() * 0.003);
                statePoint.scale.setScalar(scale);
            }
            
            renderer.render(scene, camera);
        }
        
        // ==================== BUTTON HANDLERS ====================
        function resetView() {
            sphereRotation = { x: 0, y: 0 };
            camera.position.set(2.5, 2, 2.5);
            camera.lookAt(0, 0, 0);
            scene.rotation.y = 0;
        }
        
        function toggleAnimation() {
            animating = !animating;
        }
        
        function toggleAxes() {
            showAxes = !showAxes;
            axesGroup.visible = showAxes;
        }
        
        // ==================== INIT ====================
        init();
    </script>
</body>
</html>
